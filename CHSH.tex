\documentclass[12pt]{article}
\usepackage[letter, margin=1in]{geometry}        % Changing the margins
\usepackage{amsmath, mathrsfs, amssymb, physics} % Multiple packages, all new symbols
\usepackage{graphicx}                            % For inserting pictures
\usepackage{titlesec}                            % Better titles
\usepackage{titling}                             % Makes my title look a little better
\usepackage{xcolor, listings}                    % Python/Programming Syntax Highlighting
\usepackage{parskip}                             % Better paragraph formatting
\usepackage{multirow}                            % New way to format tables
\usepackage{array}                               % More ways to format tables
\usepackage[braket, qm]{qcircuit}                % For making quantum circuit diagrams
% Hyperref is for changing how links appear in text
\usepackage[colorlinks=true, urlcolor=blue, linkcolor=blue, citecolor=blue]{hyperref}

\setcounter{secnumdepth}{0} % Removes section numbering


\usepackage{titling}
% Corrected title hooks for vertical and horizontal centering
\renewcommand\maketitlehooka{\null\vfill\begin{center}}
\renewcommand\maketitlehookd{\end{center}\vfill\null}

% Title formatting
\pretitle{\LARGE\bfseries}
\posttitle{\par\vspace{2em}}
\preauthor{\large}
\postauthor{\par\vspace{1em}}
\predate{\large}
\postdate{\par\vspace{3em}}

\graphicspath{{./images/}}

\title{Violating the CHSH Inequality: \\ Empirical Evidence of Quantum Nonlocality \\ (PHY 3035 Quantum Mechanics Honors)}
\author{Damien Koon\\[0.5em]
April 2025} % Add small vertical space after name
\date{} % Empty date to remove automatic date


% Python syntax highlighting
\lstdefinestyle{python}{
    language=Python,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    commentstyle=\color{green!50!black},
    stringstyle=\color{red},
    showstringspaces=false,
    breaklines=true,
    frame=tb,
    numbers=left,
    stepnumber=1
}

\makeatletter
\renewcommand\tableofcontents{%
  \null\hfill\textbf{\Large\contentsname}\hfill\null\par
  \@mkboth{\MakeUppercase\contentsname}{\MakeUppercase\contentsname}%
  \@starttoc{toc}%
}
\makeatother

% Allows for comments by the author, delete before publishing
% Example Usage:
% \com{DK}{This is a comment!}
% \bcom{DK}{This is a bolded comment!}
\newcommand{\com}[2]{\textcolor{#1}{[#1: #2]}}
\newcommand{\bcom}[2]{\textcolor{#1}{\textbf{[#1: #2]}}}
\definecolor{DK}{rgb}{0,1,0} % Set the color of your comment based on author initials


\begin{document}
\maketitle

\begin{abstract}
The Clauser–Horne–Shimony–Holt (CHSH) inequality provides an experimentally testable framework for Bell’s theorem, leading to John Clauser’s pioneering Bell tests which were recognized by the 2022 Nobel Prize in Physics. This paper acts as a pedagogical exposition aimed at undergraduate students and simultaneously replicates and extends CHSH experiments to explore quantum nonlocality across three computational settings: (1) an ideal (noiseless) simulation, (2) a noisy simulation (to emulate decoherence), and (3) execution on IBM quantum hardware. In each case, entangled Bell states are prepared and measured with optimized settings, leading to the demonstration of violations of the classical bound, $|S| \leq 2$. Our results empirically validate Bell’s theorem and demonstrate that quantum correlations remain robust even under realistic noise. This work serves as a practical guide for educators, students, and researchers who wish to reproduce this foundational experiment in quantum information in their own environments.
\end{abstract}

\newpage
\tableofcontents
\newpage
\section{Introduction}

We begin by introducing the required background knowledge adopted from the  formalism of quantum information as described by Nielsen and Chuang \cite{Quantum_Information}. We then explain and derive the CHSH inequality, including Tsirelson's bound. Finally, we will then go through the code to experimentally reproduce the results of the CHSH experiment on IBM quantum hardware\cite{ibm_quantum}. By experimentally violating the CHSH inequality and thereby proving Bell’s theorem, the CHSH experiment delivers unambiguous evidence of nonlocal quantum entanglement, laying foundational groundwork for quantum information theory.

\section{Qubits}

Quantum bits, or "qubits," are quantum representations of information. Physically, a qubit can be made from any quantum system with two distinct states. For example a photon of light being polarized either horizontally or vertically or an electron being spin up or spin down. Physically, qubits are either spin up or spin down with respect to an external magnetic field instead of being in a "zero" or "one" state. 

$$
\ket{0} = \ket{\uparrow} \hspace{2cm} \ket{1} = \ket{\downarrow}
$$


A singular qubit can be either zero or one (or both!) and they are represented mathematically by
$$
\ket{\psi} = \ket{0} = \begin{pmatrix} 1 \\ 0 \end{pmatrix} \hspace{2cm} \ket{\psi} = \ket{1} = \begin{pmatrix} 0 \\ 1 \end{pmatrix}
$$

Similarly to classical bits, qubits can be either 0 or 1, however, they can also leverage superposition and be in both states simultaneously.
$$
\ket{\psi} = \frac{1}{\sqrt{2}} (\ket{0} + \ket{1}) = \frac{1}{\sqrt{2}} \ket{0} + \frac{1}{\sqrt{2}}\ket{1}
$$

In this case, $\frac{1}{\sqrt{2}}$ is the "probability amplitude" of each state. To find the individual probability, we square the modulus of the values, $|\frac{1}{\sqrt{2}}|^2 = 0.5$. \footnote{The modulus might seem superfluous in this case, but is standard practice when working with complex numbers, which we will see later.} Therefore, the qubit is 50\% in the $\ket{0}$ state and 50\% in the $\ket{1}$ state. We can write the probability of measuring these states as follows

$$
P(\ket{0}) = |\frac{1}{\sqrt{2}}|^2 = 0.5 \hspace{2cm} P(\ket{1}) = |\frac{1}{\sqrt{2}}|^2 = 0.5 
$$

The qubit will stay in this superposition until it interacts with the environment or is measured, then it will collapse into one of the states, depending on the probability. Either $\ket{\psi} = \ket{0}$ or $\ket{\psi} =\ket{1}$ could be observed. 

A more general way to represent qubits is as follows, where $|\alpha|^2$ and $|\beta|^2$ are the probabilities of being in the $\ket{0}$ and $\ket{1}$ states, respectively.

$$
\ket{\psi} = 
\begin{pmatrix}
    \alpha \\
    \beta
\end{pmatrix} = 
\alpha \begin{pmatrix} 1 \\ 0 \end{pmatrix} + 
\beta \begin{pmatrix} 0 \\ 1 \end{pmatrix} =
\alpha\ket{0} + \beta\ket{1}
$$

If this is how a single qubit can be represented, how do we represent a multi-qubit system? 

For now, let's continue using the same matrix notation, but with a 2-qubit system. We previously represented $\ket{0}$ and $\ket{1}$ by

$$
\ket{0} = \begin{pmatrix} 1 \\ 0 \end{pmatrix}
\hspace{2cm}
\ket{1} = \begin{pmatrix} 0 \\ 1 \end{pmatrix}
$$

We will now represent a 2-qubit system by

$$
\ket{00} = \begin{pmatrix} 1 \\ 0 \\ 0 \\ 0 \end{pmatrix}
\hspace{2cm}
\ket{01} = \begin{pmatrix} 0 \\ 1 \\ 0 \\ 0 \end{pmatrix}
$$

$$
\ket{10} = \begin{pmatrix} 0 \\ 0 \\ 1 \\ 0 \end{pmatrix}
\hspace{2cm}
\ket{11} = \begin{pmatrix} 0 \\ 0 \\ 0 \\ 1 \end{pmatrix}
$$

Writing out a five‐qubit state as a 32×1 column would be cumbersome, so instead we build a 32‐dimensional space by "tensoring" five two‐dimensional spaces.

This tensor notation can also be reduced by represented it inside of a ket. This notation is read right to left. Thus, the first qubit in this system is 1, and not a 0 as you might expect.

$$
\ket{0} \otimes \ket{1} \otimes \ket{0} \otimes \ket{1} \otimes \ket{1} = \ket{01011}
$$

The tensor product takes the possible states and expands it to show every possible permutation of the states, it combines separate quantum systems into one joint system, keeping track of all possible combinations of their states.

For the rest of the paper, we will be focusing on two-qubit systems. This is how we can generally represent two qubits tensored together:

$$
(\alpha\ket{0} + \beta\ket{1}) \otimes (\gamma\ket{0} + \delta\ket{1}) = \alpha \gamma \ket{00} + \beta \gamma \ket{10} + \alpha \delta \ket{01} +\beta \delta \ket{11}
$$

By tensoring these qubits together, we have collected all possible outcomes of the qubits and their probabilities, where now $|\alpha \gamma|^2$ is the probability for measuring $\ket{00}$ and so on.

\subsection{Qubit Manipulation}

\subsubsection{Matrix Operations}
Before we proceed with manipulating qubits, we must first define a matrix operation, the Hermitian conjugate, $U^\dagger$, pronounced "U dagger." To perform this operation, you must take the transpose of the matrix and then apply the complex conjugate, or vice versa. Basic examples will be shown in the next section.
$$
(U^{T})^{*} = (U^*)^T = U^\dagger
$$ 

For a unitary matrix, a matrix times its Hermitian conjugate, will equal the identity.
$$
U^{\dagger}U = I
$$

For a Hermitian matrix, a matrix is equal to its Hermitian conjugate. This also implies that Hermitian matrices are their own inverses.
$$
U = U^{\dagger}
$$

\subsubsection{Qubit Gates}

In classical computing, there are logic gates, which operate on binary inputs. For example, the AND gate and the OR gate for two binary inputs. They are frequently used in computer engineering to manipulate classical information.

\begin{figure}[h]
    \centering
    \includegraphics[scale=1]{AND_OR}
    \caption{AND and OR Logic Gates.}
    \cite{AND_OR_Logic_Gates}
    \label{fig:AND_OR}
\end{figure}

This leads into the idea of quantum logic gates, or simply qubit gates.\cite{Quantum_Information} 

Now to explain qubit gates, I will show various examples of how they change qubits. However, for the CHSH experiment, we will focus on the H, CNOT, and RY gates.

Recall that all quantum gates are unitary, but only those satisfying $U^2=I$ happen to be Hermitian.

\subsubsection{The Pauli Matrices}

We will start with the Pauli matrices, X, Y, Z (Also $\sigma_x, \sigma_y, \sigma_z$). Each of these gates apply to a single qubit. 

The Pauli-X Gate:
$$
X = \begin{bmatrix}
0 & 1 \\
1 & 0
\end{bmatrix}
$$

The X gate is both unitary and Hermitian, but what does it do?

$$
XX^\dagger = I \hspace{2cm} X = X^\dagger
$$


The X gate can be used to change a $\ket{0}$ to a $\ket{1}$ or a $\ket{1}$ to a $\ket{0}$. 



% X |0>
$$
X \vert 0 \rangle = 
\begin{bmatrix} 0 & 1 \\ 1 & 0 \end{bmatrix}
\begin{bmatrix} 1 \\ 0 \end{bmatrix}
=
\begin{bmatrix} 0\cdot1 + 1\cdot0 \\ 1\cdot1 + 0\cdot0 \end{bmatrix}
=
\begin{bmatrix} 0 \\ 1 \end{bmatrix} = \vert 1 \rangle.
$$

% X |1>
$$
X \vert 1 \rangle = 
\begin{bmatrix} 0 & 1 \\ 1 & 0 \end{bmatrix}
\begin{bmatrix} 0 \\ 1 \end{bmatrix}
=
\begin{bmatrix} 0\cdot 0 + 1\cdot 1 \\ 1\cdot 0 + 0\cdot 1 \end{bmatrix}
=
\begin{bmatrix} 1 \\ 0 \end{bmatrix}
= \vert 0 \rangle.
$$


The Pauli-Y Gate:
$$
Y = \begin{bmatrix}
0 & -i \\
i & 0
\end{bmatrix}
$$

$$
YY^\dagger = I \hspace{2cm} Y = Y^\dagger
$$

The Y gate is noticeably different with the addition of the imaginary number, i. We will later see how this can be visualize with the Bloch sphere. For now, we will just see what happens when we apply it to $\ket{0}$ and $\ket{1}$

% Y |0>
$$
Y \vert 0 \rangle = 
\begin{bmatrix} 0 & -i \\ i & 0 \end{bmatrix}
\begin{bmatrix} 1 \\ 0 \end{bmatrix}
=
\begin{bmatrix} 0\cdot 1 + (-i)\cdot 0 \\ i\cdot 1 + 0\cdot 0 \end{bmatrix}
=
\begin{bmatrix} 0 \\ i \end{bmatrix}
= i \vert 1 \rangle.
$$

% Y |1>
$$
Y \vert 1 \rangle = 
\begin{bmatrix} 0 & -i \\ i & 0 \end{bmatrix}
\begin{bmatrix} 0 \\ 1 \end{bmatrix}
=
\begin{bmatrix} 0\cdot 0 + (-i)\cdot 1 \\ i\cdot 0 + 0\cdot 1 \end{bmatrix}
=
\begin{bmatrix} -i \\ 0 \end{bmatrix}
= -i\, \vert 0 \rangle.
$$

The Pauli-Z Gate:
$$
Z = \begin{bmatrix}
1 & 0 \\
0 & -1
\end{bmatrix}
$$

$$
ZZ^\dagger = I \hspace{2cm} Z = Z^\dagger
$$

% Z |0>
$$
Z \vert 0 \rangle = 
\begin{bmatrix} 1 & 0 \\ 0 & -1 \end{bmatrix}
\begin{bmatrix} 1 \\ 0 \end{bmatrix}
=
\begin{bmatrix} 1\cdot 1 + 0\cdot 0 \\ 0\cdot 1 + (-1)\cdot 0 \end{bmatrix}
=
\begin{bmatrix} 1 \\ 0 \end{bmatrix}
= \vert 0 \rangle.
$$

% Z |1>
$$
Z \vert 1 \rangle = 
\begin{bmatrix} 1 & 0 \\ 0 & -1 \end{bmatrix}
\begin{bmatrix} 0 \\ 1 \end{bmatrix}
=
\begin{bmatrix} 1\cdot 0 + 0\cdot 1 \\ 0\cdot 0 + (-1)\cdot 1 \end{bmatrix}
=
\begin{bmatrix} 0 \\ -1 \end{bmatrix}
= -\vert 1 \rangle.
$$

The three Pauli matrices are the simplest of the quantum gates and they aid in understanding how a qubit can be transformed. We will later see how these qubits geometrically on the Bloch sphere.

\subsubsection{Essential Quantum Gates}
We will next introduce the rest of the gates that will be needed for the CHSH experiment. 

\vspace{1cm}

The Hadamard Gate:
$$
H = \frac{1}{\sqrt{2}}
\begin{bmatrix}
1 &  1 \\
1 & -1 
\end{bmatrix}
$$
The Hadamard Gate is central to entanglement, because it creates an equal superposition state from a $\ket{0}$ and $\ket{1}$ state.

$$
H \vert 0 \rangle = 
\frac{1}{\sqrt{2}} \begin{bmatrix} 1 & 1 \\ 1 & -1 \end{bmatrix}
\begin{bmatrix} 1 \\ 0 \end{bmatrix}
=
\frac{1}{\sqrt{2}} \begin{bmatrix} 1\cdot1 + 1\cdot0 \\ 1\cdot1 + (-1)\cdot0 \end{bmatrix}
=
\frac{1}{\sqrt{2}} \begin{bmatrix} 1 \\ 1 \end{bmatrix}
=
\frac{1}{\sqrt{2}} \left( \vert 0 \rangle + \vert 1 \rangle \right).
$$

$$
H \vert 1 \rangle = 
\frac{1}{\sqrt{2}} \begin{bmatrix} 1 & 1 \\ 1 & -1 \end{bmatrix}
\begin{bmatrix} 0 \\ 1 \end{bmatrix}
=
\frac{1}{\sqrt{2}} \begin{bmatrix} 1\cdot0 + 1\cdot1 \\ 1\cdot0 + (-1)\cdot1 \end{bmatrix}
=
\frac{1}{\sqrt{2}} \begin{bmatrix} 1 \\ -1 \end{bmatrix}
=
\frac{1}{\sqrt{2}} \left( \vert 0 \rangle - \vert 1 \rangle \right).
$$

We originally start with $\ket{0}$, but after applying the Hadamard gate, we have an equal superposition where the qubit is 50\% in $\ket{0}$ and 50\% in $\ket{1}$. For the CHSH experiment, we will not be using $H\ket{1}$, but it is instructive. %Typically qubits being in the $\ket{0}$ state. 


The Controlled X Gate:
$$
CNOT =
\begin{bmatrix}
1 &  0  &  0  & 0 \\
0 &  1  &  0  & 0 \\
0 &  0  &  0  & 1 \\
0 &  0  &  1  & 0 \\
\end{bmatrix}
$$

So far, we have only considered single qubit gates, but the CNOT is a two qubit gate. Consider the CNOT gate to be an X gate on a target qubit, but it only activates if the second, "control" qubit is a 1.


% Apply CNOT to |00>
$$
CNOT \cdot \ket{00} =
CNOT \cdot
\begin{bmatrix} 1 \\ 0 \\ 0 \\ 0 \end{bmatrix}
=
\begin{bmatrix} 1 \\ 0 \\ 0 \\ 0 \end{bmatrix} = \ket{00}
$$

% Apply CNOT to |01>
$$
CNOT \cdot \ket{01} =
CNOT \cdot
\begin{bmatrix} 0 \\ 1 \\ 0 \\ 0 \end{bmatrix}
=
\begin{bmatrix} 0 \\ 1 \\ 0 \\ 0 \end{bmatrix} = \ket{01}
$$

% Apply CNOT to |10>
$$
CNOT \cdot \ket{10} =
CNOT \cdot
\begin{bmatrix} 0 \\ 0 \\ 1 \\ 0 \end{bmatrix}
=
\begin{bmatrix} 0 \\ 0 \\ 0 \\ 1 \end{bmatrix} = \ket{11}
$$

% Apply CNOT to |11>
$$
CNOT \cdot \ket{11} =
CNOT \cdot
\begin{bmatrix} 0 \\ 0 \\ 0 \\ 1 \end{bmatrix}
=
\begin{bmatrix} 0 \\ 0 \\ 1 \\ 0 \end{bmatrix} = \ket{10}
$$

If this seems confusing, the Visual examples of the CNOT gate will be shown in the later section, Quantum Circuits. 

Looking forward to entanglement, what happens if the control qubit is in an equal superposition of $\ket{0}$ and $\ket{1}$? As we will soon see, the CNOT gate and the Hadamard gate are central to the entanglement between two qubits.

The RY gate is a rotation operator gate about y-axis. This gate is mentioned in particular because it relates to the CHSH experiment. RX and RZ gates exist as well.

As an interesting note, the RY gate is the only outlined in this list that is unitary but not Hermitian for arbitrary $\theta$. However, it is Hermition only if $\theta = 
\pi$

$$
RY(\theta) =
\begin{bmatrix}
cos(\theta / 2) & -sin(\theta / 2) \\
sin(\theta / 2) &  cos(\theta / 2)
\end{bmatrix}
$$

It is of note that the explicit matrix form is not always needed. The RY gate can also be represented by 

$$
e^{-i \frac{\theta}{2} Y}
$$

Which can be expanded out by using the Taylor series

$$
e^{-i \frac{\theta}{2} Y} = cos(\frac{\theta}{2})I - isin(\frac{\theta}{2})Y
$$

$$
= cos(\frac{\theta}{2})\begin{bmatrix}
1 & 0 \\
0 &  1
\end{bmatrix} - isin(\frac{\theta}{2})\begin{bmatrix}
0 & -i \\
i &  0
\end{bmatrix} = \begin{bmatrix}
cos(\theta / 2) & -sin(\theta / 2) \\
sin(\theta / 2) &  cos(\theta / 2)
\end{bmatrix}
$$

You might recall that we have the Y gate, which is a rotation of $\pi$ radians about the y-axis.

$$
Y = \begin{bmatrix}
0 & -i \\
i & 0
\end{bmatrix}
$$

So what happens if we plug in $\pi$ to the RY gate?

$$
RY(\pi) =
\begin{bmatrix}
0 & -1 \\
1 &  0
\end{bmatrix}
$$

This looks similar to the Y gate, but it's missing the i term! Why is that? This is due to the idea of global and relative phase. The Y gate represents a rotation by $\pi$ radians about the y-axis, but with an additional global phase of -i

$$
RY(\pi) = -iY
$$

The Pauli-Y gate is defined with a conventional global phase to satisfy anti-commutativity along with the Pauli-X and Pauli-Z operators. This is not highly relevant, and the key takeaway should be that $RY(\pi)$ and $Y$ perform the same physical rotation, but differ by a global phase of -i.

\subsubsection{Phase}

First let us take a base qubit, $\ket{0}$, and then let us apply a Hadamard gate to split it into a superposition:

$$
\ket{\psi} = H\ket{0} = \frac{1}{\sqrt{2}}( \ket{0}  + \ket{1})
$$

Now that we have an equal superposition, let's apply a Z gate and see what happens.

$$
Z\left(\frac{1}{\sqrt{2}}\left(\ket{0}+\ket{1}\right)\right)
= \frac{1}{\sqrt{2}} \begin{pmatrix} 1 & 0 \\ 0 & -1 \end{pmatrix} \begin{pmatrix} 1 \\ 1 \end{pmatrix}
= \frac{1}{\sqrt{2}} \begin{pmatrix} 1 \\ -1 \end{pmatrix}
$$


$$
Z\ket{\psi} = \frac{1}{\sqrt{2}}( \ket{0} - \ket{1})
$$

This is very similar to just applying a Hadamard gate to $\ket{0}$, but it has changed $\ket{1}$ to $-\ket{1}$ Recall Euler's identity and note that we can rewrite this like this.

$$
Z\ket{\psi} = \frac{1}{\sqrt{2}}( \ket{0} + e^{i\pi}\ket{1})
$$

This is the idea of relative phase. Recall that the Z gate rotates the qubit around the z-axis by $\pi$, so what if we want to rotate it by some angle $\phi$? 

A general form:
$$
\ket{\psi} = \alpha\ket0 + e^{i\phi}\beta\ket1
$$

But why is the $e^{i\phi}$ only on $\ket{1}$? Let's try putting it on both the 0 and 1 kets.

$$
\ket{\psi} = e^{i\phi} \alpha \ket{0} + e^{i\phi} \beta \ket{1}) = e^{i\phi}(\alpha \ket{0} + \beta \ket{1})
$$

The global phase, $e^{i\phi}$, has no observable consequences and doesn't change the probabilities of getting a measurement result and is considered to be physically irrelevant.\cite{Quantum_Information}

$$e^{i\phi}(\alpha \ket{0} + \beta \ket{1}) = \alpha \ket{0} + \beta \ket{1}$$


% A more detailed explanation:
%https://physics.stackexchange.com/questions/758363/on-the-irrelevance-of-the-global-phase-factor


Note that if both phases are different, it just reduces to the relative phase.

$$
\ket{\psi} = e^{i\theta} \alpha \ket{0} + e^{i\phi} \beta \ket{1}) = \alpha \ket{0} + e^{i(\phi-\theta)}\beta \ket{1}
$$

Also note that the probabilities do not change since $|e^{i\phi}|^2 = 1$

The phase factor on the 1 ket instead of the 0 ket by standard convention. It can be rewritten to be on the 0 ket instead if needed

$$
\ket{\psi} = \alpha \ket{0} + e^{i\phi} \beta \ket{1}) = e^{i2\pi} \alpha \ket{0} + e^{i\phi} \beta \ket{1}) = e^{i(2\pi - \phi)} \alpha \ket{0} + e^{i\phi} \beta \ket{1})
$$


\subsubsection{Bloch Sphere}

We need more ways to represent qubits other than Dirac notation. It would be beneficial to have a geometric representation, so we can better visualize changes to a qubit. Thus, the physicist, Felix Bloch, introduced a sphere on which qubits can be represented as a point on the surface.

Higher vertically means that the qubit is more likely to be $\ket{0}$ and vice versa for $\ket{1}$

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.75]{BlochSphere.png}
    \caption{The Bloch Sphere.}
    \cite{Bloch_Sphere}
    \label{fig:Bloch_Sphere}
\end{figure}


But what are these different states along the equator? 

$$
\ket{+} = \frac{1}{\sqrt{2}}( \ket{0}  + \ket{1})
\hspace{1cm}
\ket{-} = \frac{1}{\sqrt{2}}( \ket{0}  - \ket{1})
$$
$$
\ket{+i} = \frac{1}{\sqrt{2}}( \ket{0}  + i\ket{1})
\hspace{1cm}
\ket{-i} = \frac{1}{\sqrt{2}}( \ket{0}  - i\ket{1})
$$

There are in between $\ket{0}$ and $\ket{1}$, so that would imply that the states are equally probable. The only difference between them is their phase. 

$$
\ket{+} = \frac{1}{\sqrt{2}}( \ket{0}  + e^{i 2\pi}\ket{1})
\hspace{1cm}
\ket{-} = \frac{1}{\sqrt{2}}( \ket{0}  + e^{i \pi}\ket{1})
$$
$$
\ket{+i} = \frac{1}{\sqrt{2}}( \ket{0}  + e^{i \frac{\pi}{2}}\ket{1})
\hspace{1cm}
\ket{-i} = \frac{1}{\sqrt{2}}( \ket{0}  + e^{i \frac{3\pi}{2}} \ket{1})
$$

\subsection{Quantum Circuits and Entanglement}

\subsubsection{Quantum Circuits}
So far, we have discussed gates, phase, and the Bloch sphere, but each of these discussions has only involved a single qubit.\footnote{Except for the CNOT gate} How can we apply a gate to a single qubit in a multi-qubit system, and how can we represent this system graphically? 

To draw the base diagram, first consider a 3 qubit system without any gates applied
$$
\Qcircuit @C=2em @R=1.5em {
\lstick{\ket{q_0}} & \qw & \qw & \qw & \qw \\
\lstick{\ket{q_1}} & \qw & \qw & \qw & \qw \\
\lstick{\ket{q_2}} & \qw & \qw & \qw & \qw
}
$$

To understand why this diagram is chosen, let us recall the AND and OR gates from the previous section, and let's create a classical circuit.

The Classical Circuit in Figure 3 takes 3 inputs, A, B, and C and provides 1 output, Q, after passing A, B, and C through 2 AND gates and 1 OR gate. 

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.3]{ClassicalCircuit.png}
    \caption{Classical Circuit comprised of 2 AND gates and 1 OR gate.}
    \cite{ClassicalCircuit}
    \label{fig:ClassicalCircuit}
\end{figure}


This idea from classical computing leads into the idea of the quantum circuit. A graph with lines as "wires" which read left to read as different points in time with each qubit in a system having a separate wire.

Now what if we want to apply an X gate to qubit 0, a Y gate to qubit 1, and a Z gate to qubit 2?

$$
\Qcircuit @C=2em @R=1.5em {
\lstick{\ket{q_0}} & \gate{X} & \qw & \qw & \qw \\
\lstick{\ket{q_1}} & \gate{Y} & \qw & \qw & \qw \\
\lstick{\ket{q_2}} & \gate{Z} & \qw & \qw & \qw
}
$$

Quantum circuits are intuitive and very useful for visualizing a qubit system. Let's explore a few more examples.

This system has an RY gate applied on qubit 0, and a CNOT gate controlled by qubit 0 and targeted to qubit 1. 

$$
\Qcircuit @C=1.8em @R=1.5em {
\lstick{\ket{q_0}} & \gate{R_y(\theta)} & \ctrl{1} & \qw \\
\lstick{\ket{q_1}} & \qw              & \targ    & \qw
}
$$

This system has two of each Pauli gate applied to its respective qubit. Recall that the X, Y, and Z gates are unitary, so this circuit is equivalent to a circuit without any gates applied, like the one at the start of this section.

$$
\Qcircuit @C=2em @R=1.5em {
\lstick{\ket{q_0}} & \gate{X} & \gate{X} & \qw & \qw \\
\lstick{\ket{q_1}} & \gate{Y} & \gate{Y} & \qw & \qw \\
\lstick{\ket{q_2}} & \gate{Z} & \gate{Z} & \qw & \qw
}
$$



\subsubsection{Measurement}

We briefly mentioned measurement previously when discussing the probabilities, but now we can see how it is implemented in a quantum circuit. 

We have created a quantum circuit with one qubit with a Hadamard gate applied, and then after it is applied, the qubit is measured. 
$$
\Qcircuit @C=2em @R=1.5em {
\lstick{\ket{q_0}} & \gate{H} & \meter & \qw
}
$$

Recall that the Hadamard gate takes a $\ket{0}$ or a $\ket{1}$, and splits it into equal probabilities. Thus, if it is measured, the qubit will have a 50/50 chance to collapse into either state. 

Consider the X-basis states, $\ket{+}$ and $\ket{-}$, and a qubit in the state $\ket{\psi} = \alpha\ket{0} + \beta{\ket{1}}$, such that $|\alpha|^2 + |\beta|^2 = 1$

By the Born rule\cite{Quantum_Information}, the probability of the qubit being in the $\ket{+}$ is

$$
\bra{\psi} \ket{+} \bra{+} \ket{\psi} = |\bra{+}\ket{\psi}|^2 = \frac{\bra{0} + \bra{1}}{\sqrt{2}}(\alpha\ket{0} + \beta{\ket{1}}) = \frac{\alpha + \beta}{\sqrt{2}}
$$

Where the probability is
$$
p(+) = |\frac{\alpha + \beta}{\sqrt{2}}|^2 = \frac{|\alpha + \beta|^2}{2}
$$

And similarly for $\ket{-}$

$$
\bra{\psi} \ket{-} \bra{-} \ket{\psi} = |\bra{-}\ket{\psi}|^2 = \frac{\bra{0} - \bra{1}}{\sqrt{2}}(\alpha\ket{0} + \beta{\ket{1}}) = \frac{\alpha - \beta}{\sqrt{2}}
$$

Where the probability is
$$
p(-) = |\frac{\alpha - \beta}{\sqrt{2}}|^2 = \frac{|\alpha - \beta|^2}{2}
$$

So if $\alpha = 1, \beta=0$, an equal probability emerges.

$$
p(+) = \frac{|1+0|^2}{2} = 1/2 \hspace{2cm} p(+) = \frac{|1-0|^2}{2} = 1/2
$$

\subsubsection{Bell States and Entanglement}

As we know from the Hadamard gate, we can take a basis state, and split it into a superposition. So what if we take two $\ket{0}$ qubits, apply a Hadamard gate, and then apply a CNOT gate?

$$
\Qcircuit @C=1.5em @R=1.5em {
\lstick{\ket{0}} & \gate{H} & \ctrl{1} & \qw \\
\lstick{\ket{0}} & \qw      & \targ    & \qw
}
$$

This two qubit circuit is a very important circuit, and we will be seeing it frequently. This is the classical example of entanglement and is referred to as a Bell state. More specifically, this is a "\textit{maximally} entangled two-qubit Bell state."

This Bell state can be mathematically represented by 

$$
\ket{\Phi^+} = \frac{1}{\sqrt{2}} ( \ket{00} + \ket{11} )
$$

 There are 4 different maximally entangled Bell states, but $\ket{\Phi^+}$ is the most common and will be used in this CHSH experiment.

$$
\ket{\Phi^+} = \frac{1}{\sqrt{2}} ( \ket{00} + \ket{11} ) \hspace{2cm} 
\ket{\Phi^-} = \frac{1}{\sqrt{2}} ( \ket{00} - \ket{11} )
$$

$$
\ket{\Psi^+} = \frac{1}{\sqrt{2}} ( \ket{01} + \ket{10} ) \hspace{2cm} 
\ket{\Psi^-} = \frac{1}{\sqrt{2}} ( \ket{01} - \ket{10} )
$$

But what does it mean for two qubits to be entangled? What is interesting about Bell states?

First, let's consider a two qubit system, $\ket{\psi_0}$ and $\ket{\psi_1}$

$$
\ket{\psi_0} = \alpha\ket{0} + \beta\ket{1}
$$

$$
\ket{\psi_1} = \gamma\ket{0} + \delta\ket{1}
$$

And as we saw from the previous example earlier in the introduction,

$$
\ket{\psi_0} \otimes\ket{\psi_1} = \alpha \gamma \ket{00} + \beta \gamma \ket{10} + \alpha \delta \ket{01} +\beta \delta \ket{11}
$$

now compare this to the entangled Bell state, $\ket{\Phi^+}$

$$
\ket{\Phi^+} = \frac{1}{\sqrt{2}} ( \ket{00} + \ket{11} )
$$

Let's try to match the coefficients of the original two qubit system to the Bell state. i.e. we need to find coefficients such that

$$
\alpha\gamma = 0 \hspace{1cm} \alpha\delta=\frac{1}{\sqrt{2}} \hspace{1cm}
\beta\gamma=\frac{1}{\sqrt{2}}\hspace{1cm}
\beta\delta = 0
$$

It is impossible to match these coefficients from the sub system to the system of a Bell state. This implies the state is not separable into a product state. This is the core idea of entanglement. 

\newpage
\section{CHSH Inequality}

The CHSH inequality is a more robust version of Bell's inequality. Both are used to prove Bell's theorem, however Bell's inequality requires a noiseless environment and is practically difficult to implement.

The section will outline the theory behind the CHSH experiment, including derivations of the CHSH inequality, how the expectation values are calculated, and the true upper bound for the CHSH parameter, known as Tsirelson's bound.



\subsection{Bell's Theorem}

Bell's theorem states that no local hidden variable theory can reproduce all of the predictions of quantum mechanics. \cite{Bell1964}

A local hidden variable theory assumes that the universe operates with "hidden variables" which cannot be measured and there is no way for us to obtain information about them, with the additional principle of locality stating that objects must be influenced only by their immediate surroundings.

The principle of locality evolved from the theories of classical physics, and is central to special and general relativity. One of Einstein's primary postulates is one of locality. No information or causal influence can travel faster than the speed of light.

Einstein personally advocated for local realism, which states that there is no instantaneous action at a distance and that physical properties exist independent of observation. However, the CHSH experiment is empirical evidence against this idea of local realism.

The CHSH inequality provides a practical way to test Bell's theorem by bounding correlations between two spatially separated systems under the assumptions of a local hidden variable theory. \cite{CHSH1969}

\subsection{The CHSH parameter, S}

The CHSH parameter\footnote{Throughout this paper, \( S \) is referred to using the terms ``parameter'' and ``value'' interchangeably. However, ``parameter'' is the more accurate term.}, S, is given by
$$
S = E(A_0 B_0) - E(A_0 B_1) + E(A_1 B_0) + E(A_1 B_1)
$$

Where $E(A_i B_j)$ represents the expectation values of the product of the measurement outcomes for two qubits, of which we will name Alice and Bob.

This expression arise by strategic choice rather than by any derivation. Bell's original inequality was ineffective against experimental noise, and the CHSH improved upon Bell's ideas and designed the CHSH parameter to maximize violation of the CHSH inequality and to simplify experimentation. \cite{CHSH1969} The idea of a maximum violation will be expanded upon in future sections. 


\subsection{Expectation Values}

The CHSH parameter, S, is composed of four expectation values

$$
S = E(A_0 B_0) - E(A_0 B_1) + E(A_1 B_0) + E(A_1 B_1)
$$

Where $A_i$ and $B_j$ represent the "measurement settings" for two qubits, which we will name Alice and Bob respectively. To compute S, we must first calculate these individual expectation values.

These measurement settings correlate to what basis the qubits are being measured in. Specifically, the qubits will either be measured with respect to the X or Z basis.

To be very explicit, $A_0$ is the expectation value of Alice's qubit being observed in the Z-basis, $A_1$ is the expectation value of Alice's qubit being observed in the X-basis, $B_0$ is the expectation value of Bob's qubit being observed in the Z-basis, and $B_1$ is the expectation value of Bob's qubit being observed in the X-basis.

To ground the next calculations, let us recall that expectation values quantify how measurement outcomes on entangled qubits correlate when projected onto different bases. In particular, computing the eigenvalues and eigenvectors of the Pauli operators, $Z$ and $X$ reveals the possible outcomes as $\pm 1$ and their associated states. By explicitly finding these determinants, we confirm each measurement, setting the stage for constructing the CHSH parameter. 

$$
Z = \begin{bmatrix}
1 & 0 \\
0 & -1
\end{bmatrix}
$$

Where the eigenstates are $\ket{0}$ and $\ket{1}$, with eigenvalues of $\pm1$

$$
det(Z-\lambda I) = 0 = (1-\lambda)(-1-\lambda) \implies \lambda = \pm 1
$$

For $\lambda = +1$:
$$
(Z-I)\boldsymbol{v} = 0 
$$

$$
\begin{bmatrix}
0 & 0 \\
0 & -2
\end{bmatrix}
\begin{bmatrix}
v_1 \\
v_2
\end{bmatrix} \rightarrow v_2 = 0
$$

$$
\boldsymbol{v} = \begin{bmatrix}
1 \\
0
\end{bmatrix} = \ket{0}
$$

For $\lambda = -1$:
$$
(Z+I)\boldsymbol{v} = 0 
$$

$$
\begin{bmatrix}
2 & 0 \\
0 & 0
\end{bmatrix}
\begin{bmatrix}
v_1 \\
v_2
\end{bmatrix} \rightarrow v_1 = 0
$$

$$
\boldsymbol{v} = \begin{bmatrix}
0 \\
1
\end{bmatrix} = \ket{1}
$$

Having determined that the eigenvalues of Z are $\pm1$ with eigenstates $\ket{0}$ and $\ket{1}$, we now turn our attention to the Pauli-X operator. We will find that we get the same eigenvalues $\pm1$, however now with eigenvectors $\ket{+}$ and $\ket{-}$ respectively.

$$
X = \begin{bmatrix}
0 & 1 \\
1 & 0
\end{bmatrix}
$$

Where the eigenstates are $\ket{+}$ and $\ket{-}$, with eigenvalues of $\pm1$

$$
det(X-\lambda I) = 0 = \lambda^2 -1 \implies \lambda = \pm 1
$$

For $\lambda = +1$:
$$
(X-I)\boldsymbol{v} = 0 
$$

$$
\begin{bmatrix}
-1 & 1 \\
1 & -1
\end{bmatrix}
\begin{bmatrix}
v_1 \\
v_2
\end{bmatrix} \implies v_1 = v_2
$$

$$
\boldsymbol{v} = \frac{1}{\sqrt{2}}\begin{bmatrix}
1 \\
1
\end{bmatrix} = \ket{+}
$$

For $\lambda = -1$:
$$
(X+I)\boldsymbol{v} = 0 
$$

$$
\begin{bmatrix}
1 & 1 \\
1 & 1
\end{bmatrix}
\begin{bmatrix}
v_1 \\
v_2
\end{bmatrix} \implies v_1 = -v_2
$$

$$
\boldsymbol{v} = \frac{1}{\sqrt{2}}\begin{bmatrix}
1 \\
-1
\end{bmatrix} = \ket{-}
$$

With the eigenvalue and vectors for $Z$ and $X$ deteremined, we can now formalize the expectation value for a two-qubit measurement. 

An individual expectation value $E(A_iB_j)$ is computed by

$$
E(A_i B_j) = \bra{\psi} A_i \otimes B_j \ket{\psi}
$$

Where $\ket{\psi}$ is the shared entangled Bell state, $\ket{\Phi^+} = \frac{1}{\sqrt{2}}(\ket{00} + \ket{11})$

\subsection{The Classical Bound, $S \leq 2$}

To continue with the derivation of the classical bound, we must now assume realism and locality. This means that before Alice and Bob pick how they will measure their qubits, the outcomes are already predetermined by some underlying hidden variable, $\lambda$.

We can then write the expectation values from repeated trials where Alice and Bob record their outcomes, $a_k,b_k$ for the measurement settings $A_i,B_j$. \footnote{In practice, one replaces the ensemble average by a finite sum over $N$ trials, incurring only negligible statistical error for large $N$.}

\[
E(A_i B_j) = \frac{1}{N} \sum_{k=1}^{N} a_k(\lambda) b_k(\lambda)
\]

Where $a_k, b_k \in \{\pm1\}$ are the outcomes of a single observation, summed for the total number of trials.

If both of the outcomes are $\pm1$, then the outcomes agree, and are positively correlated. However, if one correlation is $+1$ and the other is $-1$, then  the outcomes disagree, and are negatively correlated. Thus we can write the expectation values as such


\[
E(A_i, B_j) = \frac{N_{++} - N_{+-} - N_{-+} + N_{--}}{N_{total}}
\]


To proceed with the derivation of the classical inequality, we want to make the assumption that outcomes are predetermined by some hidden variable, which we will call $\lambda$. Locality ensures that outcomes only depend on local settings, and realism assumes that outcomes exist independent of measurement.

For a fixed value of $\lambda$, with binary outcomes,

$$
a_0(\lambda), a_1(\lambda), b_0(\lambda), b_1(\lambda) \in \{\pm1\}
$$

Then the CHSH value becomes

$$
S(\lambda) = a_0(\lambda)b_0(\lambda) - a_0(\lambda)b_1(\lambda) + a_1(\lambda)b_0(\lambda) + a_1(\lambda)b_1(\lambda)
$$

Since we know the possible values of the correlations and the value for S, we can then determine the bound of S with the assumptions of realism and locality. But first, let's rewrite S to be a bit easier to work with.

$$
S(\lambda)= a_0(\lambda) [b_0(\lambda) - b_1(\lambda)] + a_1(\lambda) [b_0(\lambda) + b_1(\lambda)]
$$

Recall that each value can only take on the values of $\pm1$, so now we can tabulate all of the possible combinations of values and evaluate from there.

\begin{center}
\begin{tabular}{
  |>{\centering\arraybackslash}p{1.5cm}  % Centered column
  |>{\centering\arraybackslash}p{1.5cm} 
  |>{\centering\arraybackslash}p{1.5cm} 
  |>{\centering\arraybackslash}p{1.5cm} 
  |>{\centering\arraybackslash}p{1.5cm}| 
}
 \hline
 \multicolumn{5}{|c|}{All possible permutations} \\
 \hline
 \(b_0\) & \(b_1\) & \(b_0 - b_1\) & \(b_0 + b_1\) & \(S(\lambda)\) \\
 \hline
 \(+1\)   &  \(+1\)    & \(0\) &  \(+2\) & \(+2a_1\) \\
 \(+1\)   &  \(-1\)    & \(+2\)&  \(0\) & \(+2a_0\) \\
 \(-1\)   &  \(+1\)    & \(-2\)&  \(0\) & \(-2a_0\) \\
 \(-1\)   &  \(-1\)    & \(0\) &  \(-2\) & \(-2a_1\) \\
 \hline
\end{tabular}
\end{center}

In all cases and for any single hidden variable, $\lambda$, we can deduce the classical bound $|S(\lambda)| \leq 2$. 

This inequality is experimentally testable and as we will soon see, it can be violated with a Bell state, but how can we maximize this violation to avoid experimental noise?

To optimize the violation of the CHSH inequality, it has been found that we want Alice and Bob's measurement bases to be misaligned by $45^\circ$ on the Bloch sphere. The Z and X bases are orthogonal, so to get these optimal angles we use the RY gate to rotate by $45^\circ$. The RY gate will be applied to both qubits after they have been entangled.

Looking ahead and knowing that the value $|S(\lambda)| \leq 2$ will be violated, then what is the maximum possible violation?

\subsection{Tsirelson’s bound}

Looking ahead and knowing that the classical bound will be violated, what is the maximum possible violation within the realm of quantum mechanics?

This maximum value is known as the Tsirelson bound, named after the mathematician Boris S. Tsirelson. In his 1980 paper, Tsirelson derived the upper bound for the CHSH parameter and highlighted the differences in Bell's 1964 framework of local hidden variable theories. \cite{Tsirelson_Paper} \cite{Bell1964}

We will now use a slightly different notation than before, where expectation values are now placed inside angle brackets. Additionally, we will use the operator norm of the CHSH operator, T for our derivation. This is not the same as S, but it is directly related by the expectation value. 

$$
S =
\left\langle A_0 \otimes B_0 \right\rangle - \left\langle A_0 \otimes B_1 \right\rangle + \left\langle A_1 \otimes B_0 \right\rangle +\left\langle A_1 \otimes B_1 \right\rangle
$$

$$
S = \left\langle \psi \middle| T \middle| \psi \right\rangle
$$

$$
T = A_0 \otimes B_0 - A_0 \otimes B_1 + A_1 \otimes B_0 + A_1 \otimes B_1
$$

For any normalized value, $\ket{\psi}$, we can used the operator norm to find the inequality

\[
|\left\langle \psi \big| T \big| \psi \right\rangle| \leq ||T|| = \sqrt{||T^2||}
\]

Therefore, 
\[
|S| \leq  \sqrt{||T^2||}
\]

Before we continue with tensor algebra manipulation of T, it is vitally important to note that operations are not commutative. i.e. $A_0 A_1 \neq A_1 A_0$

$$
T = A_0 \otimes(B_0 - B_1) + A_1 \otimes(B_0 + B_1)
$$

Now as an intermediate step, let's square both sides.

$$
T^2 = [A_0 \otimes(B_0 - B_1) + A_1 \otimes(B_0 + B_1)]^2
$$

$$
T^2 = (A_0 \otimes(B_0 - B_1))^2 + (A_1 \otimes(B_0 + B_1))^2 + A_0A_1 \otimes ((B_0 - B_1)(B_0 + B_1)) + A_1 A_0 \otimes ((B_0 + B_1) ( B_0 - B_1))
$$

Let's break this into parts and first consider the square terms and 
recall that $A_i^2 = B_j^2 = I$

$$
(B_0 - B_1)^2 = 2I - (B_0B_1 + B_1B_0)
$$

$$
(B_0 + B_1)^2 = 2I + (B_0B_1 + B_1B_0)
$$

Thus,

$$
(A_0 \otimes(B_0 - B_1))^2 = A_0^2 \otimes (B_0 - B_1)^2 = I \otimes (2I - (B_0B_1 + B_1B_0))
$$

$$
(A_1 \otimes(B_0 + B_1))^2 = A_1^2 \otimes (B_0 + B_1)^2 = I \otimes (2I + (B_0B_1 + B_1B_0))
$$

Adding them together gives,

$$
I \otimes [2I - (B_0B_1 + B_1B_0) + 2I + (B_0B_1 + B_1B_0)] = I \otimes 4I = 4I
$$

Now consider the cross terms, and remember that terms are not necessarily commutative.

$$
(B_0 - B_1)(B_0 + B_1) = B_0 B_1 - B_1 B_0 = [B_0, B_1]
$$

and similarly,

$$
(B_0 + B_1)(B_0 - B_1) = B_1 B_0 - B_0 B_1= [B_1, B_0] = -[B_0, B_1]
$$

Thus the cross terms become

$$
A_0 A_1 \otimes [B_0, B_1] + A_1 A_0 \otimes (-[B_0, B_1]) = A_0 A_1 \otimes [B_0, B_1] - A_1 A_0 \otimes [B_0, B_1]
$$

$$
= (A_0 A_1 - A_1 A_0) \otimes [B_0, B_1] = [A_0, A_1] \otimes [B_0, B_1]
$$

Combining all of the terms,

$$
T^2 = 4I + [A_0, A_1] \otimes [B_0, B_1]
$$

Notice that if the commutators are zero, 

\[
T^2 = 4I \implies ||T|| = 2
\]

Thus the maximum eigenvalue is 2, and we naturally see the classical bound, 
\[
|S| = |\bra{\Phi^+}T\ket{\Phi^+}| \leq 2
\]

To continue with the derivation, we must evaluate these commutators with the commutation relations for the Pauli matrices as stated by Nielsen and Chuang\cite{Quantum_Information}.  

Recall that the values $A_0, B_0$ correlate to Z, and the values $A_1, B_1$ correlate the X. We can then derive the commutation relations for Z and X.

$$  
ZX = \begin{bmatrix} 1 & 0 \\ 0 & -1 \end{bmatrix} \begin{bmatrix} 0 & 1 \\ 1 & 0 \end{bmatrix} = \begin{bmatrix} 0 & 1 \\ -1 & 0 \end{bmatrix}.  
$$  

$$  
XZ = \begin{bmatrix} 0 & 1 \\ 1 & 0 \end{bmatrix} \begin{bmatrix} 1 & 0 \\ 0 & -1 \end{bmatrix} = \begin{bmatrix} 0 & -1 \\ 1 & 0 \end{bmatrix}.  
$$  

$$  
[Z, X] = ZX - XZ = \begin{bmatrix} 0 & 1 \\ -1 & 0 \end{bmatrix} - \begin{bmatrix} 0 & -1 \\ 1 & 0 \end{bmatrix} = \begin{bmatrix} 0 & 2 \\ -2 & 0 \end{bmatrix}.  
$$  

Compare with $2iY$:  
$$  
2iY = 2i \begin{bmatrix} 0 & -i \\ i & 0 \end{bmatrix} = \begin{bmatrix} 0 & 2 \\ -2 & 0 \end{bmatrix}.  
$$  

$$
[Z,X] = 2iY
$$

We now distinguish YAYA​ and YBYB​ as acting on Alice’s and Bob’s qubit, respectively.

\[
T^2 = 4I + [A_0, A_1] \otimes [B_0, B_1] 
\]

$$
[A_0, A_1] = [Z,X] = 2iY_A \hspace{2cm} [B_0, B_1] = [Z,X] = 2iY_B
$$

\[
T^2 = 4I + 2iY_A \otimes 2iY_B = 4I - 4(Y_A \otimes Y_B)
\]

While $Y_A$ and $Y_B$ appear mathematically indistinguishable, we must deal with them separately. Let's do this by evaluating the tensor product with respect to the bell state.

\[
\langle \Phi^+ | Y_A \otimes Y_B | \Phi^+ \rangle
\]


\[
= \frac{1}{(\sqrt{2})^2}( \bra{00} + \bra{11} | Y_A \otimes Y_B | \ket{00} + \ket{11} )
\]

It is vitally important that we keep track of which qubit we're working with.

\[
= \frac{1}{2} ( \bra{0_A} \bra{0_B} + \bra{1_A} \bra{1_B} | Y_A \otimes Y_B | \ket{0_A} \ket{0_B} + \ket{1_A} \ket{1_B} )
\]

After expanding it out, this becomes the rather messy form

\begin{align*}
= \frac{1}{2}[
  (\bra{0_A} \bra{0_B} Y_A \otimes Y_B \ket{0_A} \ket{0_B})  \\
+ (\bra{0_A} \bra{0_B} Y_A \otimes Y_B \ket{1_A} \ket{1_B}) \\
+ (\bra{1_A} \bra{1_B} Y_A \otimes Y_B \ket{0_A} \ket{0_B}) \\
+ (\bra{1_A} \bra{1_B} Y_A \otimes Y_B \ket{1_A} \ket{1_B})
]
\end{align*}

With some matrix multiplication, we find that $\bra{0}Y\ket{0} = \bra{1}Y\ket{1}=0$, which greatly simplifies our equation to just the cross terms

\[
= \frac{1}{2}[
\bra{0_A} Y_A \ket{1_A}\bra{0_B} Y_B \ket{1_B} 
+ \bra{1_A} Y_A \ket{0_A} \bra{1_B} Y_B  \ket{0_B}]
\]

Now all that remains is finish the matrix multiplication.

\[
\bra{0}Y\ket{1} = \begin{pmatrix} 1 & 0 \end{pmatrix}
\;
\begin{pmatrix}
  0 & -i \\[6pt]
  i & 0
\end{pmatrix}
\;
\begin{pmatrix} 0 \\[3pt] 1 \end{pmatrix}
\;= -i
\]

Similarly we find,

\[
\bra{1}Y\ket{0} = \begin{pmatrix} 0 & 1 \end{pmatrix}
\;
\begin{pmatrix}
  0 & -i \\[6pt]
  i & 0
\end{pmatrix}
\;
\begin{pmatrix} 1 \\[3pt] 0 \end{pmatrix}
\;= i
\]

Which then brings our original form to the rather simple equation,

\[
\frac{1}{2}((-i)^2 + (i)^2) = -1
\]

Recall that we had to use the bell state to get this value, which simultaneously transformed our $T^2$ value

\[
\langle T^2 \rangle = 4 - 4 \langle Y_A \otimes Y_B \rangle = 8
\]

We then get the result

\[
|S| \leq ||T|| = 2 \sqrt{2}
\]

With quantum mechanics, we find the maximum value for the CHSH value is $2\sqrt{2}$. This is the theoretical limit, even with higher-dimensional entanglement, no quantum state or measurement strategy will exceed this. Physically it demonstrates that quantum correlations are stronger than classical, however still bounded by $2\sqrt{2}$

\newpage
\section{CHSH Experiment}
Qiskit, or the Quantum Information Software Kit, is an open source software development kit (SDK) created by IBM researchers to execute programs on quantum computers.
Qiskit has various tools for creating and manipulating quantum information. 

Qiskit allows usage of their prototype quantum devices on the IBM Quantum Platform or by using locally run simulators. In this section there are 3 different programs. Two of which were written using the Aer simulator, and one which is compatible with IBM quantum hardware.

Only snippets of the full code will be shown. Only code that directly relates to the CHSH experiment will be mentioned and little to no code relating to the Qiskit backend will be shown. The complete code can be found on \url{https://github.com/acroscopic/CHSH/} and it is recommended to reference while reading this paper.

\subsection{Aer Simulator and IBM Hardware}
We will begin by using the Aer simulator module for Qiskit to recreate the CHSH experiment, and then we will use real IBM Quantum Hardware.\cite{qiskit}. Three total backends were used. Two Aer simulator backends and a backend to connect with an IBM Quantum Computer. The two Aer simulators used are the Qasm Simulator which simulates a noisy quantum circuit, and the Statevector Simulator, which is an ideal or noiseless quantum circuit.

\subsection{Statevector Simulator}

Let's begin by using the Aer Statevector simulator. This is a noiseless backend, which means that it will produce the same value each time the program is run.

We begin by defining angles. We will later reference these angles when we use the RY gate.

\begin{lstlisting}[style=python]
# These are the angles at which we're measuring our qubits
angles = {
    # Pure X-basis measurement
    'A0': np.pi / 2,

    # Pure Z-basis measurement
    'A1': 0,

    # X-basis (Rotated 45 degrees)
    'B0': np.pi / 4,

    # Z-basis (Rotated 45 degrees)
    'B1': -np.pi / 4
}
\end{lstlisting}

\newpage

 Next, let's define the measurement settings we'll be using,

\begin{lstlisting}[style=python]
# Recall S = E(A0B0) - E(A0B1) + E(A1B0) + E(A1B1)
# This is just setting up the settings so we can loop over them
# We will subtract the E(A0B1) later
measurement_settings = [
    ('A0', 'B0'), # Add
    ('A0', 'B1'), # Subtract (later)
    ('A1', 'B0'), # Add
    ('A1', 'B1'), # Add
]
\end{lstlisting}

We need loop through the measurement settings, create a Bell state, and apply the measurement rotations. 

\begin{lstlisting}[style=python]
    # Start looping through the measurement settings
    # We need to use both qubits, which we've named Alice and Bob
    for alice, bob in measurement_settings:

        # Create a quantum circuit with 2 qubits
        qc = QuantumCircuit(2)
        
        # First, we need to create Bell state between Alice and Bob
        # Put a Hadamard gate on Alice (Qubit 0)
        qc.h(0)    
        # Then, put a CNOT gate on Alice and Bob (Controlled by Alice)  
        qc.cx(0, 1)
        
        # Apply RY gate rotations to the qubits to align the measurement basis
        qc.ry(-angles[alice], 0)  # Alice's basis
        qc.ry(-angles[bob], 1)    # Bob's basis
\end{lstlisting}

Now that we have prepared the system, We will make a measurement and find the expectation values. This is done by simulating the statevectors for each measurement setting, and then squaring the probability amplitude. All that remains is compute the CHSH value.

\begin{lstlisting}[style=python]
if alice == 'A0' and bob == 'B1':
    S -= E # Subtract only E(A0B1)
else:
    S += E # Add everything else
print(f"E({alice}{bob}) = {E}")

print(f"S   = {S}")
print(f"2√2 = {2*np.sqrt(2)}")
\end{lstlisting}

\subsubsection{Results}
\begin{figure}[h]
    \centering
    \includegraphics[scale=0.8]{StateVector.png}
    \caption{Terminal output from running Aer\_StateVector.py}
    \label{fig:StateVector_results}
\end{figure}

The Aer statevector simulator has provided a noiseless environment to run the CHSH experiment. We can see that the value obtain is identical to $2\sqrt{2}$ and will always produce this result when run. However running the CHSH experiment on real hardware does not have the luxury of a noiseless environment. To see what we might expect, let's continue with the Aer simulator, but with a new noisy backend.

\subsection{Qasm Simulator}

The Qasm Simulator works similarly to the Statevector Simulator. We will begin again by creating a bell state between two qubits, Alice, q[0] and Bob, q[1]. 2 classical bits are also created for storing the results of measurement. 

\begin{lstlisting}[style=python]
q = QuantumRegister(2,'q')
c = ClassicalRegister(2,'c')

def bell():
    # Create a quantum circuit
    qc = QuantumCircuit(q, c) 
    alice = q[0]         # The first qubit
    bob = q[1]           # The second qubit
    qc.h(alice)          # Hadamard Gate
    qc.cx(alice, bob)    # CNOT Gate
    
    return qc    
\end{lstlisting}

Recall the graphical visualization of this bell state. The only difference between this circuit and the code, is that two classical bits are created for storing the results after measurement. 

$$
\Qcircuit @C=1.5em @R=1.5em {
\lstick{\ket{Alice}} & \gate{H} & \ctrl{1} & \qw \\
\lstick{\ket{Bob}} & \qw      & \targ    & \qw
}
$$

\newpage
The next step is to measure the qubits and store them in the classical bits. However, before measurement, the RY gate is applied.

\begin{lstlisting}[style=python]
def measure(qc, angle, qubit, cbit):
    qc.ry(-angle, qubit)
    qc.measure(qubit, cbit)
    return qc
\end{lstlisting}

$$
\Qcircuit @C=1.5em @R=1.5em {
\lstick{\ket{Alice}} & \gate{H} & \ctrl{1} &  \gate{RY(\theta)} & \qw & \meter & \qw\\
\lstick{\ket{Bob}} & \qw      & \targ    &  \gate{RY(\theta)} & \qw & \meter & \qw
}
$$


Now we need to figure out a way to calculate the expectation values. Recall that the individual expectation values are calculated by 

$$
E(A_i, B_j) = \frac{N_{++} - N_{+-} - N_{-+} + N_{--}}{N_{total}}
$$

\begin{lstlisting}[style=python]
def expectation(counts):
    total = sum(counts.values())
    count_00 = counts.get('00', 0)
    count_11 = counts.get('11', 0)
    count_01 = counts.get('10', 0)
    count_10 = counts.get('01', 0)
    E = (count_00 + count_11 - count_01 - count_10) / total
    return E
\end{lstlisting}

You might notice that $count\_01 = counts.get(’10’)$ and $count\_10 = counts.get(’01’)$. This is due to Qiskit inherently ordering bitstrings from right to left instead of left to right.

Now that the setup is done, it is time to implement the CHSH experiment directly.

\newpage
\begin{lstlisting}[style=python]
def CHSH():
    backend = Aer.get_backend('qasm_simulator')
    # Uses the noisy simulator backend
    
    S = 0 # initializes the CHSH value

    # These angles provide the maximum violation of the CHSH inequality, known as Tsirelson's bound
    angles = {
        'A0': np.pi / 2,   
        'A1': 0,            
        'B0': np.pi / 4,   
        'B1': -np.pi / 4
    }
    measurement_settings = [
        ('A0', 'B0'),    
        ('A0', 'B1'),
        ('A1', 'B0'),
        ('A1', 'B1'),
    ]
    for alice, bob in measurement_settings:
        qc = bell()
        
        # Apply Alice's A0 and A1 measurements on the 0th qubit and store it in the 0th bit for each measurement setting
        qc = measure(qc, angles[alice], 0, 0)
        
        # Apply Bob's B0 and B1 measurements on the 1st qubit and store it in the 1st bit for each measurement setting
        qc = measure(qc, angles[bob], 1, 1)

        # 10 million iterations for the expectation values
        transpiled_qc = transpile(qc, backend)
        job = backend.run(transpiled_qc, shots=10000000) 
        result = job.result()
        counts = result.get_counts()
        
    # Calculate the expectation value for each measurement setting
        E = expectation(counts)

        # S = E(A_0 B_0) - E(A_0 B_1) + E(A_1 B_0) + E(A_1 B_1)
        if alice == 'A0' and bob == 'B1':  
            S -= E 
        else:  
            S += E
    return S
\end{lstlisting}

\subsubsection{Results}

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.8]{results.png}
    \caption{Terminal output from running Aer\_Qasm.py}
    \label{fig:Qasm_results}
\end{figure}

After running the code, with a total of 10 million iterations per expectation value, we get a final CHSH value of 2.8277, which is just under the maximum bound of $2\sqrt{2} \approx 2.82842...$

Since the Qasm simulator is a noisy quantum circuit simulator, if you do not have a high enough shot count, values above Tsirelson's bound can be achieved. This would normally be a major alarm, but this is an issue inherent in the Qasm simulator, and with finite sampling in general. If you use a higher shot count, the values get closer to the bound, $2\sqrt{2}$, and are more likely to stay under the bound. 

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.8]{QASM_Break.png}
    \caption{Noise-induced violation of Tsirelson's bound.}
    \label{fig:Qasm_violation_results}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.55]{range(2^20,2^30).png}
    \caption{Tabulated S parameter values alongside the shots used, highlighting an issue inherent in finite sampling. We see that as higher amounts of calculations as done, we start to converge to $2\sqrt{2}$, however it will not remain strictly below or above the line.}
    \label{fig:Calculated_S_Values_Against_Shot_Range_2^20_2^30}
\end{figure}

\subsection{Execution on IBM Quantum Hardware}
Previously, all code has been run using the Aer simulator and did not interface with any real quantum hardware. It is highly relevant to empirically replicate the results of the CHSH experiment using a real quantum computer \cite{ibm_quantum}. The setup is different, but the theory behind it is not. 

Since there is a lot of setup for IBM hardware, more Qiskit specific aspects of the code will be shown. For this section in particular, it is recommended to view the full code while reading: \url{https://github.com/acroscopic/CHSH/blob/main/CHSH_Experiment.py}. However, only code snippets will be included in this paper for brevity.

First, we need to set up the type of backend we want to use. We will filter for hardware with 127 qubits, which is the modern "Eagle" processor-based systems via IBM Quantum\cite{ibm_quantum}.
\begin{lstlisting}[style=python]
backend = service.least_busy(simulator=False, operational=True, min_num_qubits=127)
\end{lstlisting}

Instead of running lots of calculations to find the expectation values as before, hardware requires a more analytic approach. In addition, the angle for the RY gate will be parametrized between equally spaced values over a full 0 to $2\pi$ rotation. This will allow us to see values that do and don't violate the inequality, and how we can optimize it.

\begin{lstlisting}[style=python]
# Parametrize different angles for the RY gate
theta = Parameter("$\\theta$")
number_of_phases = 20
phases = np.linspace(0, 2 * np.pi, number_of_phases)

# Creating the quantum circuit in the same manner as before
qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0, 1)
qc.ry(theta, 0)
\end{lstlisting}

One of the biggest difference between the previous Aer simulator code and this version, is that expectation values are written in terms of the observables as Pauli matrices, the X and Z gates. Where X and Z are tensored together. This is just an alternative method to calculate the same expectation values as before.

\begin{lstlisting}[style=python]
# S = <ZZ> - <ZX> + <XZ> + <XX>
observable = SparsePauliOp.from_list([
   ("ZZ", 1),  #   E(A_0 B_0)
   ("ZX", -1), # - E(A_0 B_1)
   ("XZ", 1),  #   E(A_1 B_0)
   ("XX", 1)   #   E(A_1 B_1)
])    
\end{lstlisting}

Since we are running this code on hardware, we need to modify our data to fit the specific hardware that is available before we submit the job to queue and wait to receive the results. After doing that, we can run the job.

\begin{lstlisting}[style=python]
# Running the CHSH Experiment after aligning with the specifics of the backend.
job = estimator.run(pubs=[pub])
result = job.result()

# Expectation values for the observable
S_values = result[0].data.evs[0] 
print(S_values)

violation = np.any(np.abs(S_values) > 2)
print(f"CHSH violation detected: {violation}")

# Unique identifier for job
print(f"Job ID: {job.job_id()}") 

# Should be 'DONE' if successful
print(f"Job status: {job.status()}") 
\end{lstlisting}

\subsubsection{Results}

After running the code on IBM's quantum computer in Ukraine, Kyiv, we get multiple CHSH values corresponding to the different angles of the RY gates, many of which violate the classical bound \( |S| \leq 2 \).


\begin{figure}[h]
    \centering
    \includegraphics[scale=0.6]{IBM.png}
    \caption{Terminal output from running CHSH\_experiment.py}
    \label{fig:results}
\end{figure}

\newpage
\section{Conclusion}
After executing the CHSH experiment on both a noiseless and a noisy Aer Simulators and on IBM hardware, we observed the CHSH parameter, \( S > 2 \), violating the classical bound of \( |S| \leq 2 \). This empirical violation of the CHSH inequality provides strong evidence against local hidden variable theories, which assume that outcomes are determined by hidden properties independent of distant measurements. 

By violating this inequality, we have empirically validated Bell's theorem, demonstrating that non-local realism theories can fully describe quantum correlations. More specifically, the results reject local realism, which is the joint assumptions of locality and realism. Quantum mechanics inherently incorporates non-local correlations through entangled states, as seen by the Bell state used in this experiment.

This violation implies that quantum mechanics exhibits non-locality. While this does not imply instantaneous communication due to the no-signaling theorem, it confirms that quantum systems cannot be described by the local deterministic methods from classical physics without violating this empirical evidence.

The noisy simulator and hardware results highlight the fragility of quantum correlations in practical settings. Despite this, the measured violations consistently surpass S = 2.

These findings underscore the necessity of embracing quantum theory and its inherently non-classical framework to be able to describe the fundamental aspects of nature. The results align with the Copenhagen interpretation, and the violation challenges many classically held intuitions about causality and locality. 

In summary, this experiment shows that quantum mechanics is not solely a statistical tool, but a fundamental framework to describe reality. 

\newpage

\section{Acknowledgements}

This paper was written as an honors project for the undergraduate Quantum Mechanics course, PHY 3035, at the Florida Institute of Technology. 

I owe my deepest gratitude to Dr. Souvik Das, whose support made this work possible and for doing an outstanding job structuring my introduction to the world of quantum. He generously stayed late to guide my work, furthered my knowledge, meticulously proofread, and found more typos and grammar slip-ups than I care to admit. Dr. Das also provided me with invaluable presentation opportunities: twice with his Quantum Computing Research Group and once at a lecture attended by students from mathematics, physics, and space science, and my fellow peers in PHY 3035.

My thanks go to Krupa Pothiwala and Grant Lindell for their enthusiastic collaboration. From the earliest brainstorming sessions in the problem sets for PHY 3035, their constructive feedback in proofreading, and their dedication that pushed this project to a higher standard.

I am also grateful to Scott Demarest for his clear explanation of the fundamental limitations on separability of entangled particles, and for kindly allowing me to use his derivation demonstrating that entangled particles cannot be decomposed into a product state of two subsystems.

Finally, I would like to extend my thanks to Florida Tech for fostering an environment where undergraduate research can flourish, and I am thankful to all of the faculty, staff, and fellow students who contributed their time and expertise, directly or indirectly, to my education.

\newpage
\section{Bibliography}
\begin{thebibliography}{1} % Number of sources

    \bibitem{Quantum_Information} Nielsen, M. A., \& Chuang, I. L. \textit{Quantum Computation and Quantum Information}. Cambridge University Press, 2010.

    \bibitem{Bell1964} Bell, J. S. "On the Einstein Podolsky Rosen Paradox." \textit{Physics Physique Fizika}, vol. 1, pp. 195–200, 1964. \url{https://cds.cern.ch/record/111654/files/vol1p195-200_001.pdf}

    \bibitem{CHSH1969} Clauser, J. F., Horne, M. A., Shimony, A., \& Holt, R. A. "Proposed Experiment to Test Local Hidden-Variable Theories." \textit{Physical Review Letters}, vol. 23, no. 15, pp. 880–884, 1969. \url{https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.23.880}

    \bibitem{AND_OR_Logic_Gates} Toheeb Olaide/Class Notes, "logic-gates-symbol-csc-classnotesng.jpg," classnotes.ng, \url{https://classnotes.ng/lesson/logic-gate}

    \bibitem{Bloch_Sphere} Wyrd Smythe/Logos Con Carne, "bloch-hdr.png," logosconcarne.com, March 15, 2021, \url{https://logosconcarne.com/2021/03/15/qm-101-bloch-sphere/}

    \bibitem{ClassicalCircuit} Liam Cope, Logic Circuit: Definition, Examples, Types and FAQs, January 2025, , \url{https://engineerfix.com/electrical/plc/logic-circuit/}

    \bibitem{Tsirelson_Paper} Tsirelson, B. S. “Quantum Generalizations of Bell’s Inequality.” \textit{Letters in Mathematical Physics}, vol. 4, pp. 93–100, 1980.

    \bibitem{qiskit} IBM, \textit{Qiskit: An Open-Source Framework for Quantum Computing}, 2025, 2.0, \url{https://qiskit.org}

    \bibitem{ibm_quantum} IBM, \textit{IBM Quantum Computing}, 2025, \url{https://quantum-computing.ibm.com}

\end{thebibliography}




\end{document}
